{"$message_type":"diagnostic","message":"unused variable: `start`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":453,"byte_end":458,"line_start":18,"line_end":18,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"pub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":453,"byte_end":458,"line_start":18,"line_end":18,"column_start":12,"column_end":17,"is_primary":true,"text":[{"text":"pub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {","highlight_start":12,"highlight_end":17}],"label":null,"suggested_replacement":"_start","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `start`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:18:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_start`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `len`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":465,"byte_end":468,"line_start":18,"line_end":18,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"pub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {","highlight_start":24,"highlight_end":27}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":465,"byte_end":468,"line_start":18,"line_end":18,"column_start":24,"column_end":27,"is_primary":true,"text":[{"text":"pub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {","highlight_start":24,"highlight_end":27}],"label":null,"suggested_replacement":"_len","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `len`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:18:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_len`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `kind`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":475,"byte_end":479,"line_start":18,"line_end":18,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"pub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":475,"byte_end":479,"line_start":18,"line_end":18,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"pub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":"_kind","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"you might have meant to pattern match on the similarly named constant `MIN_PAYLOAD`","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":475,"byte_end":479,"line_start":18,"line_end":18,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"pub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":"raw::tests::MIN_PAYLOAD","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `kind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:18:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn raw(start: u64, len: u64, kind: u32) -> RawEntry {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: if this is intentional, prefix it with an underscore\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0mpub fn raw(start: u64, len: u64, \u001b[0m\u001b[0m\u001b[38;5;10m_\u001b[0m\u001b[0mkind: u32) -> RawEntry {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you might have meant to pattern match on the similarly named constant `MIN_PAYLOAD`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0mpub fn raw(start: u64, len: u64, \u001b[0m\u001b[0m\u001b[38;5;9mkind\u001b[0m\u001b[0m: u32) -> RawEntry {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0mpub fn raw(start: u64, len: u64, \u001b[0m\u001b[0m\u001b[38;5;10mraw::tests::MIN_PAYLOAD\u001b[0m\u001b[0m: u32) -> RawEntry {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `buf`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":825,"byte_end":828,"line_start":32,"line_end":32,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":825,"byte_end":828,"line_start":32,"line_end":32,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":"_buf","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `buf`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:32:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_buf`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `entry`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":844,"byte_end":849,"line_start":32,"line_end":32,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":38,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":844,"byte_end":849,"line_start":32,"line_end":32,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":38,"highlight_end":43}],"label":null,"suggested_replacement":"_entry","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `entry`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:32:38\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_entry`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `buf`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":1429,"byte_end":1432,"line_start":50,"line_end":50,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"pub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {","highlight_start":17,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":1429,"byte_end":1432,"line_start":50,"line_end":50,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"pub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {","highlight_start":17,"highlight_end":20}],"label":null,"suggested_replacement":"_buf","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `buf`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:50:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m50\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_buf`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `buf`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":2211,"byte_end":2214,"line_start":71,"line_end":71,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn new(buf: &'a [u8]) -> Self {","highlight_start":16,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":2211,"byte_end":2214,"line_start":71,"line_end":71,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn new(buf: &'a [u8]) -> Self {","highlight_start":16,"highlight_end":19}],"label":null,"suggested_replacement":"_buf","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `buf`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:71:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(buf: &'a [u8]) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_buf`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":5101,"byte_end":5123,"line_start":173,"line_end":173,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        assert_eq!(e.size, 20);","highlight_start":9,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:173:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m173\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.size, 20);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":5133,"byte_end":5164,"line_start":174,"line_end":174,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:174:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":5174,"byte_end":5202,"line_start":175,"line_end":175,"column_start":9,"column_end":37,"is_primary":false,"text":[{"text":"        assert_eq!(e.length, 0x9000);","highlight_start":9,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:175:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m175\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.length, 0x9000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":5212,"byte_end":5232,"line_start":176,"line_end":176,"column_start":9,"column_end":29,"is_primary":false,"text":[{"text":"        assert_eq!(e.typ, 1);","highlight_start":9,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:176:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m176\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.typ, 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":7907,"byte_end":7929,"line_start":267,"line_end":267,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        assert_eq!(e.size, 20);","highlight_start":9,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:267:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m267\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.size, 20);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":7939,"byte_end":7970,"line_start":268,"line_end":268,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:268:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m268\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":7980,"byte_end":8008,"line_start":269,"line_end":269,"column_start":9,"column_end":37,"is_primary":false,"text":[{"text":"        assert_eq!(e.length, 0x9000);","highlight_start":9,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:269:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m269\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.length, 0x9000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":8018,"byte_end":8038,"line_start":270,"line_end":270,"column_start":9,"column_end":29,"is_primary":false,"text":[{"text":"        assert_eq!(e.typ, 1);","highlight_start":9,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:270:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m270\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.typ, 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":8312,"byte_end":8334,"line_start":280,"line_end":280,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        assert_eq!(e.size, 28);","highlight_start":9,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:280:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m280\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.size, 28);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":8344,"byte_end":8375,"line_start":281,"line_end":281,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:281:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m281\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":8385,"byte_end":8413,"line_start":282,"line_end":282,"column_start":9,"column_end":37,"is_primary":false,"text":[{"text":"        assert_eq!(e.length, 0x1111);","highlight_start":9,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:282:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m282\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.length, 0x1111);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":8423,"byte_end":8443,"line_start":283,"line_end":283,"column_start":9,"column_end":29,"is_primary":false,"text":[{"text":"        assert_eq!(e.typ, 2);","highlight_start":9,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:283:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m283\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.typ, 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":8806,"byte_end":8837,"line_start":298,"line_end":298,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:298:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m298\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 13 previous errors; 7 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 13 previous errors; 7 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0793`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0793`.\u001b[0m\n"}
