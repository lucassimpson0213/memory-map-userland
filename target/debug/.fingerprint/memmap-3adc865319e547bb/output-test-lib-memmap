{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/raw.rs","byte_start":2684,"byte_end":2688,"line_start":88,"line_end":88,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    buf.push(tipo);","highlight_start":14,"highlight_end":18}],"label":"expected `u8`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/raw.rs","byte_start":2679,"byte_end":2683,"line_start":88,"line_end":88,"column_start":9,"column_end":13,"is_primary":false,"text":[{"text":"    buf.push(tipo);","highlight_start":9,"highlight_end":13}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs","byte_start":98280,"byte_end":98284,"line_start":2571,"line_end":2571,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, value: T) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `u8` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":2688,"byte_end":2688,"line_start":88,"line_end":88,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"    buf.push(tipo);","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:88:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    buf.push(tipo);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `u32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2571:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2571\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn push(&mut self, value: T) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u32` to a `u8` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    buf.push(tipo\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/raw.rs","byte_start":2704,"byte_end":2713,"line_start":89,"line_end":89,"column_start":14,"column_end":23,"is_primary":true,"text":[{"text":"    buf.push(base_addr);","highlight_start":14,"highlight_end":23}],"label":"expected `u8`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/raw.rs","byte_start":2699,"byte_end":2703,"line_start":89,"line_end":89,"column_start":9,"column_end":13,"is_primary":false,"text":[{"text":"    buf.push(base_addr);","highlight_start":9,"highlight_end":13}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs","byte_start":98280,"byte_end":98284,"line_start":2571,"line_end":2571,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, value: T) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u8` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":2713,"byte_end":2713,"line_start":89,"line_end":89,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    buf.push(base_addr);","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:89:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    buf.push(base_addr);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `u64`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2571:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2571\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn push(&mut self, value: T) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u8` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m89\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    buf.push(base_addr\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/raw.rs","byte_start":2729,"byte_end":2735,"line_start":90,"line_end":90,"column_start":14,"column_end":20,"is_primary":true,"text":[{"text":"    buf.push(length);","highlight_start":14,"highlight_end":20}],"label":"expected `u8`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/raw.rs","byte_start":2724,"byte_end":2728,"line_start":90,"line_end":90,"column_start":9,"column_end":13,"is_primary":false,"text":[{"text":"    buf.push(length);","highlight_start":9,"highlight_end":13}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs","byte_start":98280,"byte_end":98284,"line_start":2571,"line_end":2571,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, value: T) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u64` to a `u8` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":2735,"byte_end":2735,"line_start":90,"line_end":90,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"    buf.push(length);","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:90:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    buf.push(length);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `u64`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2571:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2571\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn push(&mut self, value: T) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u64` to a `u8` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m90\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    buf.push(length\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/raw.rs","byte_start":2751,"byte_end":2755,"line_start":91,"line_end":91,"column_start":14,"column_end":18,"is_primary":true,"text":[{"text":"    buf.push(size);","highlight_start":14,"highlight_end":18}],"label":"expected `u8`, found `u32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/raw.rs","byte_start":2746,"byte_end":2750,"line_start":91,"line_end":91,"column_start":9,"column_end":13,"is_primary":false,"text":[{"text":"    buf.push(size);","highlight_start":9,"highlight_end":13}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs","byte_start":98280,"byte_end":98284,"line_start":2571,"line_end":2571,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    pub fn push(&mut self, value: T) {","highlight_start":12,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert a `u32` to a `u8` and panic if the converted value doesn't fit","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":2755,"byte_end":2755,"line_start":91,"line_end":91,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"    buf.push(size);","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":".try_into().unwrap()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:91:14\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m91\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    buf.push(size);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `u8`, found `u32`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2571:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2571\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn push(&mut self, value: T) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you can convert a `u32` to a `u8` and panic if the converted value doesn't fit\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m91\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    buf.push(size\u001b[0m\u001b[0m\u001b[38;5;10m.try_into().unwrap()\u001b[0m\u001b[0m);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[38;5;10m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `buf`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/frames.rs","byte_start":4121,"byte_end":4124,"line_start":146,"line_end":146,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/frames.rs","byte_start":4121,"byte_end":4124,"line_start":146,"line_end":146,"column_start":19,"column_end":22,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":19,"highlight_end":22}],"label":null,"suggested_replacement":"_buf","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `buf`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/frames.rs:146:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_buf`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `entry`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/frames.rs","byte_start":4140,"byte_end":4145,"line_start":146,"line_end":146,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":38,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/frames.rs","byte_start":4140,"byte_end":4145,"line_start":146,"line_end":146,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"pub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {","highlight_start":38,"highlight_end":43}],"label":null,"suggested_replacement":"_entry","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `entry`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/frames.rs:146:38\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m146\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn push_entry(buf: &mut Vec<u8>, entry: RawEntry) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_entry`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `buf`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/frames.rs","byte_start":5168,"byte_end":5171,"line_start":185,"line_end":185,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"pub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {","highlight_start":17,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/frames.rs","byte_start":5168,"byte_end":5171,"line_start":185,"line_end":185,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"pub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {","highlight_start":17,"highlight_end":20}],"label":null,"suggested_replacement":"_buf","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `buf`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/frames.rs:185:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m185\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_buf`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `e`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/frames.rs","byte_start":8548,"byte_end":8549,"line_start":316,"line_end":316,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub fn sanitize(e: RawEntry) -> Option<MemRegion> {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/frames.rs","byte_start":8548,"byte_end":8549,"line_start":316,"line_end":316,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"pub fn sanitize(e: RawEntry) -> Option<MemRegion> {","highlight_start":17,"highlight_end":18}],"label":null,"suggested_replacement":"_e","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `e`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/frames.rs:316:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m316\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn sanitize(e: RawEntry) -> Option<MemRegion> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_e`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `buf`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":2911,"byte_end":2914,"line_start":98,"line_end":98,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"pub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {","highlight_start":17,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":2911,"byte_end":2914,"line_start":98,"line_end":98,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"pub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {","highlight_start":17,"highlight_end":20}],"label":null,"suggested_replacement":"_buf","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `buf`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:98:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn read_one(buf: &[u8]) -> Result<(RawEntry, usize), MmapError> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_buf`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `buf`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/raw.rs","byte_start":3693,"byte_end":3696,"line_start":119,"line_end":119,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn new(buf: &'a [u8]) -> Self {","highlight_start":16,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/raw.rs","byte_start":3693,"byte_end":3696,"line_start":119,"line_end":119,"column_start":16,"column_end":19,"is_primary":true,"text":[{"text":"    pub fn new(buf: &'a [u8]) -> Self {","highlight_start":16,"highlight_end":19}],"label":null,"suggested_replacement":"_buf","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `buf`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:119:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m119\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(buf: &'a [u8]) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_buf`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":6583,"byte_end":6605,"line_start":221,"line_end":221,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        assert_eq!(e.size, 20);","highlight_start":9,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:221:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m221\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.size, 20);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":6615,"byte_end":6646,"line_start":222,"line_end":222,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:222:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m222\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":6656,"byte_end":6684,"line_start":223,"line_end":223,"column_start":9,"column_end":37,"is_primary":false,"text":[{"text":"        assert_eq!(e.length, 0x9000);","highlight_start":9,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:223:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m223\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.length, 0x9000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":6694,"byte_end":6714,"line_start":224,"line_end":224,"column_start":9,"column_end":29,"is_primary":false,"text":[{"text":"        assert_eq!(e.typ, 1);","highlight_start":9,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:224:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m224\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.typ, 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9389,"byte_end":9411,"line_start":315,"line_end":315,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        assert_eq!(e.size, 20);","highlight_start":9,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:315:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m315\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.size, 20);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9421,"byte_end":9452,"line_start":316,"line_end":316,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:316:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m316\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9462,"byte_end":9490,"line_start":317,"line_end":317,"column_start":9,"column_end":37,"is_primary":false,"text":[{"text":"        assert_eq!(e.length, 0x9000);","highlight_start":9,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:317:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m317\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.length, 0x9000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9500,"byte_end":9520,"line_start":318,"line_end":318,"column_start":9,"column_end":29,"is_primary":false,"text":[{"text":"        assert_eq!(e.typ, 1);","highlight_start":9,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:318:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m318\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.typ, 1);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9794,"byte_end":9816,"line_start":328,"line_end":328,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        assert_eq!(e.size, 28);","highlight_start":9,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:328:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m328\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.size, 28);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9826,"byte_end":9857,"line_start":329,"line_end":329,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:329:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m329\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9867,"byte_end":9895,"line_start":330,"line_end":330,"column_start":9,"column_end":37,"is_primary":false,"text":[{"text":"        assert_eq!(e.length, 0x1111);","highlight_start":9,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:330:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m330\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.length, 0x1111);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":9905,"byte_end":9925,"line_start":331,"line_end":331,"column_start":9,"column_end":29,"is_primary":false,"text":[{"text":"        assert_eq!(e.typ, 2);","highlight_start":9,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:331:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m331\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.typ, 2);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"reference to packed field is unaligned","code":{"code":"E0793","explanation":"An unaligned reference to a field of a [packed] `struct` or `union` was created.\n\nThe `#[repr(packed)]` attribute removes padding between fields, which can\ncause fields to be stored at unaligned memory addresses. Creating references\nto such fields violates Rust's memory safety guarantees and can lead to\nundefined behavior in optimized code.\n\nErroneous code example:\n\n```compile_fail,E0793\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n    // A reference to a packed field causes a error.\n    let val = &foo.field1; // ERROR\n    // An implicit `&` is added in format strings, causing the same error.\n    println!(\"{}\", foo.field1); // ERROR\n}\n```\n\nCreating a reference to an insufficiently aligned packed field is\n[undefined behavior] and therefore disallowed. Using an `unsafe` block does not\nchange anything about this. Instead, the code should do a copy of the data in\nthe packed field or use raw pointers and unaligned accesses.\n\n```\n#[repr(packed)]\npub struct Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0, field2: 0 };\n\n    // Instead of a reference, we can create a raw pointer...\n    let ptr = std::ptr::addr_of!(foo.field1);\n    // ... and then (crucially!) access it in an explicitly unaligned way.\n    let val = unsafe { ptr.read_unaligned() };\n    // This would *NOT* be correct:\n    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!\n\n    // For formatting, we can create a copy to avoid the direct reference.\n    let copy = foo.field1;\n    println!(\"{}\", copy);\n\n    // Creating a copy can be written in a single line with curly braces.\n    // (This is equivalent to the two lines above.)\n    println!(\"{}\", { foo.field1 });\n\n    // A reference to a field that will always be sufficiently aligned is safe:\n    println!(\"{}\", foo.field2);\n}\n```\n\n### Unions\n\nAlthough creating a reference to a `union` field is `unsafe`, this error\nwill still be triggered if the referenced field is not sufficiently\naligned. Use `addr_of!` and raw pointers in the same way as for struct fields.\n\n```compile_fail,E0793\n#[repr(packed)]\npub union Foo {\n    field1: u64,\n    field2: u8,\n}\n\nunsafe {\n    let foo = Foo { field1: 0 };\n    // Accessing the field directly is fine.\n    let val = foo.field1;\n\n    // A reference to a packed union field causes an error.\n    let val = &foo.field1; // ERROR\n}\n```\n\n### Additional information\n\nNote that this error is specifically about *references* to packed fields.\nDirect by-value access of those fields is fine, since then the compiler has\nenough information to generate the correct kind of access.\n\nSee [issue #82523] for more information.\n\n[packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n[undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n[issue #82523]: https://github.com/rust-lang/rust/issues/82523\n"},"level":"error","spans":[{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1375,"byte_end":1381,"line_start":44,"line_end":44,"column_start":16,"column_end":22,"is_primary":true,"text":[{"text":"        match (&$left, &$right) {","highlight_start":16,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/raw.rs","byte_start":10288,"byte_end":10319,"line_start":346,"line_end":346,"column_start":9,"column_end":40,"is_primary":false,"text":[{"text":"        assert_eq!(e.base_addr, 0x1000);","highlight_start":9,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"/Users/lucassimpson/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":1294,"byte_end":1316,"line_start":42,"line_end":42,"column_start":1,"column_end":23,"is_primary":false,"text":[{"text":"macro_rules! assert_eq {","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0793]\u001b[0m\u001b[0m\u001b[1m: reference to packed field is unaligned\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/raw.rs:346:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m346\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        assert_eq!(e.base_addr, 0x1000);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 17 previous errors; 6 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 17 previous errors; 6 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0308, E0793.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0308, E0793.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0308`.\u001b[0m\n"}
